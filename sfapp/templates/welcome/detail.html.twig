{% extends 'base.html.twig' %}

{% block title %}Welcome to Smart Campus{% endblock %}

{% block head %}
    <link href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" rel="stylesheet">
{% endblock %}

{% block body %}

    <!-- Contenu principal centré -->
    <div class="d-flex justify-content-center align-items-center vh-60 flex-column">
        <h1>Détails de la salle {{ room.name }}</h1>


    <div class="d-flex justify-content-around circles-wrapper">
        <div class="circle-item">
            <div class="progress-circle-container">
                <div class="progress-circle">
                    <div class="circle-info-wave">{{ room.idAS.humidity }}%</div>
                    <svg width="200" height="200" xmlns="http://www.w3.org/2000/svg">
                        <path id="wave-path" d="" fill="#81c7f5"></path>
                    </svg>

                </div>

            </div>

        </div>

        <div class="circle-item">
            <div class="thermometer-container">
                <div class="thermometer">
                    <div class="thermometer-level"></div>
                </div>
                <div class="thermometer-bulb"> <p class="circle-info-temp"> {{ room.idAS.temperature }}°C</p></div>

            </div>
        </div>

        <div class="circle-item">
            <div class="co2-container">
                <svg viewBox="0 0 200 100" class="co2-svg">
                    <defs>
                        <!-- Gradient dynamique -->
                        <linearGradient id="co2-gradient" x1="0%" y1="100%" x2="0%" y2="0%">
                            <stop offset="0%" style="stop-color: #ffffff; stop-opacity: 1" />
                            <stop offset="100%" style="stop-color: #00ff00; stop-opacity: 1" />
                        </linearGradient>
                    </defs>
                    <!-- Texte avec contour noir -->
                    <text x="50%" y="50%" text-anchor="middle" dominant-baseline="middle"
                          fill="url(#co2-gradient)" stroke="black" stroke-width="2"
                          font-size="70" font-family="Arial, sans-serif" class="co2-text">
                        CO2
                    </text>
                </svg>
            </div>
        </div>

    </div>


        <script>
            document.addEventListener('DOMContentLoaded', () => {
                const humidity = parseFloat('{{ room.idAS.humidity }}'); // Récupérer l'humidité
                const wavePath = document.getElementById('wave-path');
                const colorText = document.querySelector('.circle-info-wave');
                const temp = parseFloat('{{ room.idAS.temperature }}');

                function updateTextColor() {

                    if(humidity >= 70)
                    {
                        if(temp < 20)
                        {
                            colorText.style.color = 'green';
                        }
                        else if(temp >= 20 && temp <= 25)
                        {
                            colorText.style.color = '#edc11d';
                        }
                        else
                        {
                            colorText.style.color = 'red';

                        }
                    }
                    else{
                        colorText.style.color = 'green';
                    }
                }

                // Met à jour la couleur dès le chargement
                updateTextColor();

                if (!isNaN(humidity)) {
                    // Calcul de la hauteur en fonction de l'humidité (max hauteur : 200)
                    const height = Math.min(200, Math.max(0, (1 - humidity / 100) * 200));



                    // Générer un chemin SVG avec une oscillation pour un effet naturel
                    function generateWavePath(offset) {
                        const waveHeight = height;
                        return `
                M0 ${waveHeight + Math.sin(offset) * 10}
                Q50 ${waveHeight - 10 + Math.cos(offset) * 10}, 100 ${waveHeight + Math.sin(offset) * 10}
                T200 ${waveHeight + Math.cos(offset) * 10}
                V200 H0 Z
            `;
                    }

                    // Animation de la vague
                    let offset = 0;
                    function animateWave() {
                        offset += 0.1; // Ajuster la vitesse de l'oscillation
                        wavePath.setAttribute('d', generateWavePath(offset));
                        requestAnimationFrame(animateWave);
                    }

                    // Initialiser la vague
                    wavePath.setAttribute('d', generateWavePath(0));
                    animateWave();
                }
            });
        </script>

        <script>
            document.addEventListener('DOMContentLoaded', () => {
                const temp = parseFloat('{{ room.idAS.temperature }}'); // Récupérer la température
                const thermometerLevel = document.querySelector('.thermometer-level');
                const colorText = document.querySelector('.circle-info-temp');// Niveau de la jauge


                function updateTextColor() {


                    if(temp >= 17 && temp <= 21)
                    {
                        colorText.style.color = 'green';
                    }
                    else if((temp > 21 && temp <= 26) || (temp < 17 && temp >= 12))
                    {
                        colorText.style.color = '#edc11d';
                    }
                    else
                    {
                        colorText.style.color = '#b22222';
                    }


                }

                updateTextColor();

                if (!isNaN(temp)) {
                    // Calculer la hauteur du niveau (150px = max, température max : 40°C)
                    const maxTemp = 40; // Température maximale attendue
                    const minTemp = -10; // Température minimale attendue
                    const clampedTemp = Math.max(minTemp, Math.min(maxTemp, temp));
                    let height
                    if(clampedTemp >= 35){
                        height = ((clampedTemp + minTemp) / (maxTemp + minTemp)) * 320;
                    }
                    else if(clampedTemp < 35 && clampedTemp >= 30)
                    {
                        height = ((clampedTemp + minTemp) / (maxTemp + minTemp)) * 330;
                    }
                    else if(clampedTemp < 30 && clampedTemp >= 25)
                    {
                        height = ((clampedTemp + minTemp) / (maxTemp + minTemp)) * 360;
                    }
                    else if(clampedTemp < 25 && clampedTemp >= 20)
                    {
                        height = ((clampedTemp + minTemp) / (maxTemp + minTemp)) * 420;
                    }
                    else if(clampedTemp < 20)
                    {
                        height = ((clampedTemp - minTemp) / (maxTemp + minTemp)) * 150;
                    }// Limiter entre min et max
                     // Échelle entre -10 et 40°C
                    thermometerLevel.style.height = `${height}px`;

                    // Définir la couleur du niveau selon la température
                    if (temp < 0) {
                        thermometerLevel.style.background = 'blue';
                    } else if (temp >= 0 && temp <= 15) {
                        thermometerLevel.style.background = '#edc11d'; // Jaune
                    } else if (temp > 15 && temp <= 25) {
                        thermometerLevel.style.background = 'orange';
                    } else if (temp > 25 && temp <= 30) {
                        thermometerLevel.style.background = 'orangered';
                    } else if (temp > 30) {
                        thermometerLevel.style.background = 'red';
                    }
                }
            });

            document.addEventListener('DOMContentLoaded', () => {
                const co2Value = parseFloat('{{ room.idAS.CO2 }}'); // Récupérer la valeur de CO2
                const gradient = document.getElementById('co2-gradient'); // Dégradé linéaire

                if (!isNaN(co2Value)) {
                    // Limiter les valeurs entre un minimum et un maximum
                    const maxCO2 = 1500; // Valeur maximale attendue
                    const minCO2 = 400; // Valeur minimale
                    const clampedCO2 = Math.max(minCO2, Math.min(maxCO2, co2Value)); // Limiter entre min et max

                    // Calculer le pourcentage d'offset pour l'animation
                    const offsetPercentage = (1 - clampedCO2 / maxCO2) * 100; // Calcul pour remplir par le bas

                    // Mettre à jour les stops du gradient pour animer le remplissage
                    const stops = gradient.querySelectorAll('stop');
                    stops[0].setAttribute('offset', `${offsetPercentage}%`); // Zone non remplie
                    stops[1].setAttribute('offset', `${offsetPercentage}%`); // Zone remplie

                    // Console pour le debugging
                    console.log(`CO2: ${co2Value} ppm, Offset: ${offsetPercentage}%`);
                }
            });
        </script>


    </div>




    <!-- Scripts JavaScript de Bootstrap -->
    <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@1.16.0/dist/umd/popper.min.js"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js"></script>
{% endblock %}